/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { DataProvider } from "ra-core";
import { DataProviderResult } from "react-admin";
import { clientsClaim } from "workbox-core";
import { precacheAndRoute } from "workbox-precaching";
import { TranscrobesDatabase } from "./database/Schema";

import RxDBProvider from "./ra-data-rxdb";
import { manageEvent, resetDBConnections } from "./SWManager";

declare const self: ServiceWorkerGlobalScope;

declare global {
  interface ServiceWorkerGlobalScope {
    tcb: Promise<TranscrobesDatabase> | null;
  }
}
let dataProvider: DataProvider | null;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching, or mode=production will not compile.
if (process.env.mode === "production") {
  const mani = self.__WB_MANIFEST;
  console.debug("Trying to precache", mani);
  precacheAndRoute(mani, {
    // Ignore all URL parameters.
    ignoreURLParametersMatching: [/.*/],
  });
}

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
//
// const serverPaths = new RegExp("/api|docs|redoc/");

// registerRoute(
//   // Return false to exempt requests from being fulfilled by index.html.
//   ({ request, url }: { request: Request; url: URL }) => {
//     // If this isn't a navigation, skip.
//     if (request.mode !== "navigate") {
//       return false;
//     }
//
//     // If this is a URL that starts with /_, skip.
//     if (url.pathname.startsWith("/_")) {
//       return false;
//     }
//
//     // If this looks like a URL for a resource, because it contains
//     // a file extension, skip.
//     if (url.pathname.match(fileExtensionRegexp)) {
//       return false;
//     }
//     if (url.pathname.match(serverPaths)) {
//       return false;
//     }
//
//     // Return true to signal that we want to use the handler.
//     return true;
//   },
//   // createHandlerBoundToURL("/index.html"),
// );

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  } else if (event.data && event.data.type === "resetDBConnections") {
    console.log("reset db connections");
    dataProvider = null;
    self.tcb = null;
    resetDBConnections().then(() => {
      console.log("Database unloaded");
      event.ports[0].postMessage("Database unloaded");
    });
  } else if (event.data && event.data.type === "DataProvider") {
    if (!dataProvider) {
      const url = new URL(self.location.href);
      dataProvider = RxDBProvider({ url: url });

      self.tcb = dataProvider.db();
    }
    dataProvider[event.data.method](event.data.collection, event.data.params).then(
      (res: DataProviderResult) => {
        event.ports[0].postMessage(res);
      },
    );
  } else if (event.data && event.data.type) {
    manageEvent(self, event);
  }
});

// Any other custom service worker logic can go here.

/**
 * This will add a fetch event listener to handle webpub files
 * WARNING! IT MUST BE ADDED LAST (see method for reasons)
 */
// const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60; // default is only a week
// initWebReaderSW({ cacheExpirationSeconds: ONE_YEAR_IN_SECS });
